
import argparse
import os
import random
import string
import time
from typing import Optional

from agent_memory_hub import MemoryClient
from agent_memory_hub.config.alloydb_config import AlloyDBConfig
from agent_memory_hub.config.redis_config import RedisConfig

try:
    from agent_memory_hub.models import MemoryScope, SemanticMemory
except ImportError:
    pass

def generate_payload(size_kb: int) -> dict:
    """Generates a random dictionary payload of approx size_kb KB."""
    # Rough approximation: 1 char = 1 byte. 
    # structured data with some metadata
    data_size = size_kb * 1024
    random_str = ''.join(
        random.choices(string.ascii_letters + string.digits, k=data_size)  # noqa: S311

    )
    return {
        "content": random_str,
        "metadata": {
            "size_kb": size_kb,
            "timestamp": time.time(),
            "type": "benchmark_payload"
        }
    }

def run_benchmark(
    backend: str, 
    region: str, 
    alloydb_config: Optional[AlloyDBConfig], 
    redis_config: Optional[RedisConfig],
    env: str,
    use_semantic: bool = False
):
    print(f"--- Benchmarking Backend: {backend.upper()} in {region} ({env}) ---")
    if use_semantic:
        print(">> Using Semantic Memory Models")
    
    # Initialize Client
    try:
        start_init = time.time()
        client = MemoryClient(
            agent_id="benchmark-agent",
            session_id=f"bench-{int(time.time())}",
            region=region,
            backend=backend,
            alloydb_config=alloydb_config,
            redis_config=redis_config,
            environment=env
        )
        print(f"Client Init Time: {time.time() - start_init:.4f}s")
    except Exception as e:
        print(f"Failed to initialize client: {e}")
        return

    sizes_kb = [1, 10, 100, 500] # 1KB, 10KB, 100KB, 500KB
    results = []

    for size in sizes_kb:
        print(f"\nTesting Payload Size: {size} KB")
        payload = generate_payload(size)
        if use_semantic:
             # Wrap payload in semantic memory
             mem_payload = SemanticMemory(
                 agent_id="benchmark-agent",
                 subject="benchmark",
                 predicate="has_payload_of_size",
                 object=f"{size}kb",
                 scope=MemoryScope.SESSION,
                 metadata=payload # Store the big payload in metadata
             )
             # Key will be auto-generated by write_model
             # key_log = "semantic_auto_key"
        else:
             mem_payload = payload
             key = f"bench_test_{size}kb"
             # key_log = key

        # TEST WRITE
        try:
            start_write = time.time()
            if use_semantic:
                client.write_model(mem_payload)
                # For read back, we need to know the ID, 
                # but write_model doesn't return it.
                # We know the ID from the local object though.
                key = f"semanticmemory/{mem_payload.id}" 
            else:
                client.write(mem_payload, key=key)
                
            write_time = time.time() - start_write
            print(f"  Write Time: {write_time:.4f}s")
        except Exception as e:
            print(f"  Write Failed: {e}")
            write_time = None

        # TEST READ
        try:
            start_read = time.time()
            data = client.recall(key=key)
            read_time = time.time() - start_read
            
            # Verify data integrity
            # Unpack if semantic
            if use_semantic and data:
                 # In raw read, we get the dict back
                 actual_content = data.get("metadata", {}).get("content")
                 expected_content = payload["content"]
            elif data:
                 actual_content = data.get("content")
                 expected_content = payload["content"]
            else:
                 actual_content = None
                 expected_content = payload["content"]

            if actual_content == expected_content:
                status = "SUCCESS"
            else:
                status = "DATA MISMATCH"
            
            print(f"  Read Time:  {read_time:.4f}s ({status})")
        except Exception as e:
            print(f"  Read Failed: {e}")
            read_time = None
            status = "ERROR"
        
        results.append({
            "size_kb": size,
            "write_time": write_time,
            "read_time": read_time,
            "status": status
        })

    # SUMMARY
    print("\n" + "="*50)
    print(f"BENCHMARK RESULTS: {backend.upper()}")
    print("="*50)
    print(f"{'Size (KB)':<10} | {'Write (s)':<10} | {'Read (s)':<10} | {'Status'}")
    print("-" * 50)
    for res in results:
        w_t = f"{res['write_time']:.4f}" if res['write_time'] else "FAIL"
        r_t = f"{res['read_time']:.4f}" if res['read_time'] else "FAIL"
        print(f"{res['size_kb']:<10} | {w_t:<10} | {r_t:<10} | {res['status']}")
    print("="*50 + "\n")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Benchmark Agent Memory Hub DB Backends"
    )
    parser.add_argument(
        "--backend", 
        choices=["adk", "alloydb", "redis", "firestore"], 
        default="adk", 
        help="Backend to test"
    )
    parser.add_argument("--region", default="us-central1", help="GCP Region")
    parser.add_argument("--env", default="dev", help="Environment (e.g., dev, prod)")
    
    # AlloyDB specific args
    parser.add_argument("--db-user", help="AlloyDB User")
    parser.add_argument("--db-pass", help="AlloyDB Password")
    parser.add_argument("--db-name", help="AlloyDB Database Name")
    parser.add_argument("--db-conn", help="AlloyDB Instance Connection Name")

    # Redis specific args
    parser.add_argument("--redis-host", help="Redis Host")
    parser.add_argument("--redis-port", default="6379", help="Redis Port")
    
    parser.add_argument(
        "--use-semantic", 
        action="store_true", 
        help="Benchmark with Semantic Models"
    )

    args = parser.parse_args()

    alloy_config = None
    if args.backend == "alloydb":
        if not all([args.db_user, args.db_pass, args.db_name, args.db_conn]):
            print(
                "Error: AlloyDB backend requires --db-user, --db-pass, "
                "--db-name, and --db-conn"
            )
            exit(1)
        
        alloy_config = AlloyDBConfig(
            user=args.db_user,
            password=args.db_pass,
            database=args.db_name,
            instance_connection_name=args.db_conn
        )

    redis_config = None
    if args.backend == "redis":
        # Check env or args
        host = args.redis_host or os.environ.get("REDIS_HOST")
        if not host:
             # Default loopback for convenience
             host = "localhost"
        
        redis_config = RedisConfig(
            host=host,
            port=int(args.redis_port)
        )

    run_benchmark(
        args.backend, 
        args.region, 
        alloy_config, 
        redis_config, 
        args.env,
        use_semantic=args.use_semantic
    )
